<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>컬러 슈터 - 수정판</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        #intro {
            background: rgba(255,255,255,0.95);
            border-radius: 15px;
            padding: 36px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.25);
            max-width: 700px;
            width: 100%;
            text-align: center;
            margin-top: 60px;
        }

        .intro-btn {
            background:#007bff;color:#fff;border:none;padding:12px 26px;border-radius:6px;cursor:pointer;font-size:18px;
        }

        .game-container {
            display:none;
            background:white;
            border-radius:15px;
            padding:20px;
            box-shadow:0 10px 30px rgba(0,0,0,0.3);
            max-width:960px;
            width:100%;
        }

        .score-board {
            text-align:center;margin-bottom:14px;font-size:20px;font-weight:bold;
        }

        .game-area {
            display:flex;
            flex-direction:column;
            gap:18px;
        }

        .target-area {
            background:#f8f9fa;
            border:3px solid #dee2e6;
            border-radius:10px;
            padding:18px;
            min-height:220px;
            position:relative;
            overflow:hidden;
        }

        .target-title {
            text-align:center;
            font-weight:bold;
            margin-bottom:12px;
            color:#495057;
        }

        .target-lanes {
            display:flex;
            gap:10px;
            justify-content:center;
            align-items:flex-end;
        }

        .target-lane {
            width:72px;
            display:flex;
            flex-direction:column-reverse;
            gap:6px;
            min-height:170px;
            align-items:center;
        }

        .target-block {
            width:72px;
            height:72px;
            border-radius:10px;
            border:2px solid rgba(0,0,0,0.12);
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            font-weight:bold;
            color:white;
            text-shadow:1px 1px 2px rgba(0,0,0,0.5);
            position:relative;
            transition:transform .25s ease;
        }

        .target-block.attackable {
            border:3px solid #ffeb3b;
            box-shadow:0 0 14px rgba(255,235,59,0.35);
            transform:translateY(-2px);
        }

        .block-number {
            font-size:18px;
            line-height:1;
        }

        .block-label {
            font-size:10px;
            opacity:0.85;
        }

        .queue-area {
            background:#f8f9fa;
            border:3px solid #dee2e6;
            border-radius:10px;
            padding:12px;
            display:flex;
            justify-content:center;
            gap:16px;
            align-items:center;
        }

        .queue-slot {
            width:62px;
            height:62px;
            border-radius:8px;
            border:2px dashed rgba(0,0,0,0.28);
            display:flex;
            align-items:center;
            justify-content:center;
            font-size:12px;
            color:#6c757d;
            position:relative;
            overflow:visible;
        }

        .queue-block {
            width:62px;
            height:62px;
            border-radius:8px;
            border:2px solid rgba(0,0,0,0.28);
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            font-weight:bold;
            color:white;
            text-shadow:1px 1px 2px rgba(0,0,0,0.5);
            position:relative;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .queue-block.added {
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
        }

        .selection-area {
            background:#343a40;
            border-radius:10px;
            padding:18px;
            color:white;
        }

        .selection-title {
            text-align:center;
            font-weight:bold;
            margin-bottom:12px;
        }

        .stacks-container {
            display:flex;
            gap:14px;
            justify-content:center;
            min-height:180px;
            align-items:flex-end;
        }

        .stack {
            display:flex;
            flex-direction:column-reverse;
            gap:6px;
            align-items:center;
        }

        .stack-block {
            width:60px;
            height:60px;
            border-radius:8px;
            border:2px solid rgba(255,255,255,0.25);
            transition:all .18s ease;
            display:flex;
            flex-direction:column;
            align-items:center;
            justify-content:center;
            font-weight:bold;
            color:white;
            text-shadow:1px 1px 2px rgba(0,0,0,0.45);
        }

        .stack-block.top-block {
            border:2px solid #2ecc71;
            cursor:pointer;
        }

        .stack-block.top-block:hover {
            transform:scale(1.06);
            box-shadow:0 0 12px rgba(255,255,255,0.12);
        }

        .stack-block:not(.top-block) {
            opacity:0.75;
            cursor:not-allowed;
        }

        /* color classes */
        .red{background:#e74c3c}.blue{background:#3498db}.green{background:#2ecc71}.yellow{background:#f1c40f;color:#333}.purple{background:#9b59b6}

        .shooting-particle {
            position:fixed;
            width:8px;
            height:8px;
            border-radius:50%;
            z-index:2000;
            pointer-events:none;
            transform:translate(-50%,-50%);
        }

        .damage-text {
            position:fixed;
            color:#ff4444;
            font-weight:bold;
            font-size:20px;
            z-index:2001;
            pointer-events:none;
            animation:damageFloat 1s ease-out forwards;
        }

        @keyframes damageFloat {
            0% { opacity:1; transform:translateY(0px) scale(1);}
            100% { opacity:0; transform:translateY(-40px) scale(1.1);}
        }

        .game-controls {
            text-align:center;
            margin-top:14px;
        }

        .btn {
            background:#007bff;
            color:white;
            border:none;
            padding:10px 16px;
            border-radius:6px;
            cursor:pointer;
            font-size:15px;
            margin:0 8px;
        }

        .message {
            text-align:center;
            margin-top:10px;
            font-weight:bold;
            min-height:22px;
        }

        .success{color:#28a745}.warning{color:#ffc107}.error{color:#dc3545}

        .modal-backdrop {
            position:fixed;
            left:0;
            top:0;
            width:100vw;
            height:100vh;
            background:rgba(0,0,0,0.5);
            display:flex;
            align-items:center;
            justify-content:center;
            z-index:3000;
        }

        .modal {
            background:white;
            padding:22px;
            border-radius:12px;
            width:90%;
            max-width:420px;
            text-align:center;
            box-shadow:0 10px 30px rgba(0,0,0,0.35);
        }

        .modal h2 {
            margin:6px 0 10px 0;
        }

        .modal p {
            margin:8px 0 18px 0;
            font-size:16px;
        }

        .modal .modal-actions {
            display:flex;
            gap:10px;
            justify-content:center;
        }

        @media (max-width:720px) {
            .target-lane {
                width:56px;
            }
            .target-block {
                width:56px;height:56px
            }
            .queue-slot,.queue-block {
                width:50px;
                height:50px;
            }
            .stack-block {
                width:50px;
                height:50px;
            }
        }
    </style>
</head>
<body>
    <div id="intro">
        <h1>컬러 슈터 게임 — 향상판</h1>
        <p>색상과 숫자를 맞춰 타겟을 제거하세요! (동시 발사 · 부드러운 연출 · 난이도 증가)</p>
        <button class="intro-btn" onclick="startIntroGame()">게임 시작</button>
    </div>

    <div class="game-container" id="gameContainer">
        <div class="score-board">
            <span>점수: <span id="score">0</span></span>
            <span style="margin-left:30px;">레벨: <span id="level">1</span></span>
            <span style="margin-left:30px;">색상 수: <span id="colorCount">5</span></span>
        </div>

        <div class="game-area">
            <div class="target-area">
                <div class="target-title">타겟 블록들 (아래에서 위로 쌓임)</div>
                <div class="target-lanes" id="targetLanes"></div>
            </div>

            <div class="queue-area" id="queueArea">
                <div class="queue-slot" id="queue0">Empty</div>
                <div class="queue-slot" id="queue1">Empty</div>
                <div class="queue-slot" id="queue2">Empty</div>
                <div class="queue-slot" id="queue3">Empty</div>
            </div>

            <div class="selection-area">
                <div class="selection-title">색상 블록 선택 (맨 위만 선택 가능, 대기열 최대 4)</div>
                <div class="stacks-container" id="stacksContainer"></div>
            </div>
        </div>

        <div class="game-controls">
            <button class="btn" onclick="resetGame()">다시 시작</button>
            <button class="btn" onclick="game.toggleAutoMode()">자동 탐지 토글</button>
        </div>

        <div class="message" id="message"></div>
    </div>

    <div id="modalRoot"></div>

    <script>
        class ColorShooterGame {
            constructor() {
                this.fullColorPool = ['red', 'blue', 'green', 'yellow', 'purple'];
                this.colorCount = 5;
                this.colors = this.fullColorPool.slice(0, this.colorCount);
                this.targetNumbers = [15, 30, 45, 60];
                this.stackNumbers = [15, 30];
                this.score = 0;
                this.level = 1;
                this.targetLanes = [[], [], [], []];
                this.stacks = [];
                this.attackQueue = [null, null, null, null];
                this.gameRunning = false;
                this.autoMode = true;
                this.matchCountSinceColorIncrease = 0;
                this._queueScanTimer = null;
            }

            initGame() {
                console.log('initGame: Initializing game state');
                this.stopQueueScanLoop();
                this.score = 0;
                this.level = 1;
                this.colorCount = 5;
                this.colors = this.fullColorPool.slice(0, this.colorCount);
                this.matchCountSinceColorIncrease = 0;
                this.attackQueue = [null, null, null, null];
                this.targetLanes = [[], [], [], []];
                this.stacks = [];
                this.gameRunning = false;

                this.generateTargetLanes();
                this.generateStacks();
                this.ensureInitialMatch();
                this.updateDisplay();
                console.log('initGame: Game initialized', { stacks: this.stacks, colors: this.colors, gameRunning: this.gameRunning });
            }

            generateTargetLanes() {
                for (let lane = 0; lane < 4; lane++) {
                    this.targetLanes[lane] = [];
                    const blockCount = 4;
                    for (let i = 0; i < blockCount; i++) {
                        const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                        const number = this.targetNumbers[Math.floor(Math.random() * this.targetNumbers.length)];
                        this.targetLanes[lane].push({ color, number, id: Date.now() + lane * 1000 + i });
                    }
                }
                console.log('generateTargetLanes: Generated lanes', this.targetLanes);
            }

            generateStacks() {
                this.stacks = [];
                for (let s = 0; s < 3; s++) {
                    const stack = [];
                    const stackHeight = 5;
                    for (let j = 0; j < stackHeight; j++) {
                        const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                        const number = this.stackNumbers[Math.floor(Math.random() * this.stackNumbers.length)];
                        stack.push({ color, number, id: Date.now() + s * 100 + j });
                    }
                    this.stacks.push(stack);
                }
                console.log('generateStacks: Generated stacks', this.stacks);
            }

            ensureInitialMatch() {
                const randomLane = Math.floor(Math.random() * 4);
                const randomStack = Math.floor(Math.random() * 3);
                const randomColor = this.colors[Math.floor(Math.random() * this.colors.length)];
                const targetNumber = this.targetNumbers[Math.floor(Math.random() * this.targetNumbers.length)];
                const stackNumber = this.stackNumbers[Math.floor(Math.random() * this.stackNumbers.length)];

                this.targetLanes[randomLane][0] = {
                    color: randomColor,
                    number: targetNumber,
                    id: Date.now()
                };

                this.stacks[randomStack][this.stacks[randomStack].length - 1] = {
                    color: randomColor,
                    number: Math.max(stackNumber, targetNumber),
                    id: Date.now()
                };
                console.log('ensureInitialMatch: Ensured initial match', { lane: randomLane, stack: randomStack, color: randomColor });
            }

            startGame() {
                this.gameRunning = true;
                this.showMessage('게임 시작! 자동 탐지 중...', 'success');
                this.updateDisplay();
                this.startQueueScanLoop();
                console.log('startGame: Game started', { gameRunning: this.gameRunning });
            }

            resetGame() {
                console.log('resetGame: Resetting game');
                this.stopQueueScanLoop();
                this.attackQueue = [null, null, null, null];
                this.stacks = [];
                this.targetLanes = [[], [], [], []];
                this.gameRunning = false;
                this.initGame();
                this.startGame();
                console.log('resetGame: Game reset completed');
            }

            getAvailableQueueSlot() {
                for (let i = 0; i < this.attackQueue.length; i++) {
                    if (this.attackQueue[i] === null || this.attackQueue[i].number <= 0) {
                        return i;
                    }
                }
                return -1;
            }

            selectBlock(stackIndex) {
                console.log('selectBlock: Called with stackIndex', stackIndex, {
                    gameRunning: this.gameRunning,
                    queue: this.attackQueue.map(q => q ? `${q.color}:${q.number}` : 'empty'),
                    stack: this.stacks[stackIndex]
                });

                if (!this.gameRunning) {
                    this.showMessage('게임이 시작되지 않았습니다!', 'error');
                    console.log('selectBlock: Game not running');
                    return;
                }

                const availableSlot = this.getAvailableQueueSlot();
                if (availableSlot === -1) {
                    this.showMessage('대기열이 가득 찼습니다!', 'warning');
                    console.log('selectBlock: Queue full');
                    return;
                }

                const stack = this.stacks[stackIndex];
                if (!stack || stack.length === 0) {
                    this.showMessage('스택이 비어 있습니다!', 'error');
                    console.log('selectBlock: Stack empty');
                    return;
                }

                const topBlock = stack[stack.length - 1];
                const queueBlock = { 
                    ...topBlock, 
                    stackIndex, 
                    id: Date.now() + Math.random(), 
                    isFiring: false,
                    queuePosition: availableSlot
                };
                
                this.attackQueue[availableSlot] = queueBlock;
                this.stacks[stackIndex].pop();

                const newColor = this.colors[Math.floor(Math.random() * this.colors.length)];
                const newNumber = this.stackNumbers[Math.floor(Math.random() * this.stackNumbers.length)];
                this.stacks[stackIndex].unshift({ color: newColor, number: newNumber, id: Date.now() + Math.random() });

                if (this.stacks[stackIndex].length > 5) this.stacks[stackIndex].shift();

                this.showMessage(`블록(${topBlock.color}, ${topBlock.number})이 대기열에 추가되었습니다.`, 'success');
                console.log(`selectBlock: Added block (${topBlock.color}, ${topBlock.number}) to queue slot ${availableSlot}`, this.attackQueue);

                requestAnimationFrame(() => {
                    this.updateStacksAndQueue();
                    if (this.autoMode) this.scanAndFireOnce();
                });
            }

            startQueueScanLoop() {
                if (this._queueScanTimer) {
                    clearInterval(this._queueScanTimer);
                    this._queueScanTimer = null;
                    console.log('startQueueScanLoop: Cleared existing timer');
                }
                this._queueScanTimer = setInterval(() => {
                    if (!this.gameRunning || !this.autoMode) return;
                    this.scanAndFireOnce();
                }, 150);
                console.log('startQueueScanLoop: Started queue scan loop');
            }

            stopQueueScanLoop() {
                if (this._queueScanTimer) {
                    clearInterval(this._queueScanTimer);
                    this._queueScanTimer = null;
                    console.log('stopQueueScanLoop: Stopped queue scan loop');
                }
            }

            toggleAutoMode() {
                this.autoMode = !this.autoMode;
                this.showMessage(`자동 탐지: ${this.autoMode ? 'On' : 'Off'}`, '');
                if (this.autoMode) this.startQueueScanLoop();
                else this.stopQueueScanLoop();
                console.log('toggleAutoMode: Auto mode set to', this.autoMode);
            }

            scanAndFireOnce() {
                if (!this.gameRunning) return;

                for (let qIndex = 0; qIndex < this.attackQueue.length; qIndex++) {
                    const q = this.attackQueue[qIndex];
                    if (!q || q.isFiring) continue;

                    let foundLane = -1;
                    for (let laneIndex = 0; laneIndex < this.targetLanes.length; laneIndex++) {
                        const lane = this.targetLanes[laneIndex];
                        if (lane.length > 0 && lane[0].color === q.color) {
                            foundLane = laneIndex;
                            break;
                        }
                    }

                    if (foundLane !== -1) {
                        this.attackQueue[qIndex].isFiring = true;
                        this.fireFromQueueIndex(qIndex, foundLane);
                    }
                }

                this.checkQueueStuck();
            }

            fireFromQueueIndex(queueIndex, laneIndex) {
                if (!this.attackQueue[queueIndex]) return;

                const queued = this.attackQueue[queueIndex];
                const lane = this.targetLanes[laneIndex];

                if (!lane || lane.length === 0) {
                    this.attackQueue[queueIndex].isFiring = false;
                    return;
                }

                const target = lane[0];
                if (!target) {
                    this.attackQueue[queueIndex].isFiring = false;
                    return;
                }

                const shotsTotal = queued.number;
                const shotsToApply = Math.min(shotsTotal, target.number);
                const shotInterval = 1000 / 15;
                let shotsFired = 0;
                const initialTargetId = target.id;
                let lastShotTime = performance.now();

                const fireLoop = (now) => {
                    if (!this.gameRunning) {
                        if (this.attackQueue[queueIndex]) {
                            this.attackQueue[queueIndex].isFiring = false;
                        }
                        return;
                    }

                    const currentBottom = this.targetLanes[laneIndex] && this.targetLanes[laneIndex][0];
                    if (!currentBottom || currentBottom.id !== initialTargetId) {
                        if (this.attackQueue[queueIndex]) {
                            this.attackQueue[queueIndex].isFiring = false;
                        }
                        requestAnimationFrame(() => this.updateTargetLanesAndQueue());
                        return;
                    }

                    if (now - lastShotTime >= shotInterval) {
                        console.log(`fireFromQueueIndex: Shot fired from queue ${queueIndex} to lane ${laneIndex}, shotsFired: ${shotsFired + 1}`);
                        this.createSingleParticle(queueIndex, laneIndex, queued.color);

                        currentBottom.number -= 1;
                        queued.number -= 1;
                        shotsFired++;
                        lastShotTime = now;

                        if (currentBottom.number <= 0) {
                            this.targetLanes[laneIndex].shift();
                            const color = this.colors[Math.floor(Math.random() * this.colors.length)];
                            const number = this.targetNumbers[Math.floor(Math.random() * this.targetNumbers.length)];
                            this.targetLanes[laneIndex].push({ color, number, id: Date.now() + Math.random() });
                        }

                        requestAnimationFrame(() => this.updateTargetLanesAndQueue());
                    }

                    if (shotsFired < shotsToApply && queued.number > 0) {
                        requestAnimationFrame(fireLoop);
                    } else {
                        this.score += shotsFired;
                        this.matchCountSinceColorIncrease += 1;

                        if (queued.number > 0) {
                            this.attackQueue[queueIndex].isFiring = false;
                            this.showMessage(`잔여값 ${queued.number}으로 대기열에 남음`, 'warning');
                        } else {
                            this.attackQueue[queueIndex] = null;
                        }

                        this.checkIncreaseColorByProgress();
                        this.checkLevelComplete();
                        requestAnimationFrame(() => {
                            this.updateTargetLanesAndQueue();
                            this.showDamageText(laneIndex, shotsFired);
                            this.showMessage(`매칭 성공! +${shotsFired}점`, 'success');
                        });
                    }
                };

                requestAnimationFrame(fireLoop);
            }

            createSingleParticle(queueIndex, laneIndex, color) {
                console.log(`createSingleParticle: Creating particle from queue ${queueIndex} to lane ${laneIndex}, color: ${color}`);
                const queueArea = document.getElementById('queueArea');
                const targetLanes = document.getElementById('targetLanes');

                const slotEl = queueArea.children[queueIndex];
                if (!slotEl) return;

                const slotRect = slotEl.getBoundingClientRect();
                const startX = slotRect.left + slotRect.width / 2;
                const startY = slotRect.top + slotRect.height / 2;

                const laneEl = targetLanes.children[laneIndex];
                if (!laneEl) return;

                const bottomBlock = laneEl.children[0];
                if (!bottomBlock) return;

                const targetRect = bottomBlock.getBoundingClientRect();
                const targetX = targetRect.left + targetRect.width / 2;
                const targetY = targetRect.top + targetRect.height / 2;

                const p = document.createElement('div');
                p.className = 'shooting-particle';

                const cssColor = window.getComputedStyle(document.querySelector('.' + color))?.backgroundColor || color;
                p.style.background = cssColor;
                p.style.left = startX + 'px';
                p.style.top = startY + 'px';
                p.style.opacity = '1';

                document.body.appendChild(p);

                const duration = 200;
                const start = performance.now();

                function easeOutQuad(t) {
                    return t * (2 - t);
                }

                function frame(now) {
                    const t = Math.min(1, (now - start) / duration);
                    const eased = easeOutQuad(t);

                    const curX = startX + (targetX - startX) * eased + (Math.random() - 0.5) * 8;
                    const curY = startY + (targetY - startY) * eased + (Math.random() - 0.5) * 8;

                    p.style.left = curX + 'px';
                    p.style.top = curY + 'px';
                    p.style.opacity = String(1 - eased);

                    const scale = 1 - 0.35 * eased;
                    p.style.transform = `translate(-50%,-50%) scale(${scale})`;

                    if (t < 1) {
                        requestAnimationFrame(frame);
                    } else {
                        if (p.parentNode) p.parentNode.removeChild(p);
                    }
                }

                requestAnimationFrame(frame);
            }

            showDamageText(laneIndex, damage) {
                const targetLanesEl = document.getElementById('targetLanes');
                const laneEl = targetLanesEl.children[laneIndex];
                if (!laneEl) return;

                const rect = laneEl.getBoundingClientRect();
                const tx = rect.left + rect.width / 2;
                const ty = rect.top + rect.height / 2;

                const d = document.createElement('div');
                d.className = 'damage-text';
                d.textContent = `-${damage}`;
                d.style.left = tx + 'px';
                d.style.top = ty + 'px';

                document.body.appendChild(d);

                setTimeout(() => {
                    if (d.parentNode) d.parentNode.removeChild(d);
                }, 900);
            }

            checkQueueStuck() {
                const availableSlots = this.getAvailableQueueSlot();
                if (availableSlots !== -1) return;

                const activeBlocks = this.attackQueue.filter(q => q !== null && q.number > 0);
                for (let q of activeBlocks) {
                    for (let lane of this.targetLanes) {
                        if (lane.length > 0 && lane[0].color === q.color) return;
                    }
                }

                this.gameRunning = false;
                this.stopQueueScanLoop();
                this.showGameOverModal(`대기열이 가득 차고 더 이상 공격할 수 없습니다. 획득 점수: ${this.score}`);
            }

            checkIncreaseColorByProgress() {
                const threshold = 4;
                if (this.matchCountSinceColorIncrease >= threshold) {
                    this.matchCountSinceColorIncrease = 0;
                    if (this.colorCount < this.fullColorPool.length) {
                        this.colorCount++;
                        this.colors = this.fullColorPool.slice(0, this.colorCount);
                        this.showMessage(`난이도 상승 — 색상 수 ${this.colorCount}개`, 'warning');
                        document.getElementById('colorCount').textContent = this.colorCount;
                    }
                }
            }

            checkLevelComplete() {
                const newLevel = Math.floor(this.score / 500) + 1;
                if (newLevel > this.level) {
                    this.level = newLevel;
                    this.showMessage(`레벨업! 레벨 ${this.level}`, 'success');
                }
            }

            showGameOverModal(message) {
                const root = document.getElementById('modalRoot');
                root.innerHTML = '';

                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop';

                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.innerHTML = `<h2>게임 오버</h2><p>${message}</p>`;

                const actions = document.createElement('div');
                actions.className = 'modal-actions';

                const retry = document.createElement('button');
                retry.className = 'btn';
                retry.textContent = '다시 플레이';
                retry.onclick = () => {
                    root.innerHTML = '';
                    this.resetGame();
                };

                const close = document.createElement('button');
                close.className = 'btn';
                close.textContent = '나가기';
                close.onclick = () => {
                    root.innerHTML = '';
                    this.showMessage('게임을 중단했습니다.');
                };

                actions.appendChild(retry);
                actions.appendChild(close);
                modal.appendChild(actions);
                backdrop.appendChild(modal);
                root.appendChild(backdrop);
            }

            updateDisplay() {
                console.log('updateDisplay: Updating full UI', { startTime: performance.now() });
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('colorCount').textContent = this.colorCount;

                this.updateTargetLanes();
                this.updateStacksAndQueue();
                console.log('updateDisplay: Full UI updated', { endTime: performance.now() });
            }

            updateTargetLanes() {
                const targetContainer = document.getElementById('targetLanes');
                targetContainer.innerHTML = '';
                this.targetLanes.forEach((lane, laneIndex) => {
                    const laneEl = document.createElement('div');
                    laneEl.className = 'target-lane';

                    lane.forEach((block, idx) => {
                        const blockEl = document.createElement('div');
                        blockEl.className = `target-block ${block.color}`;

                        if (idx === 0) {
                            blockEl.classList.add('attackable');
                            blockEl.innerHTML = `<div class="block-number">${block.number}</div><div class="block-label">ATTACK</div>`;
                        } else {
                            blockEl.innerHTML = `<div class="block-number">${block.number}</div><div class="block-label">TARGET</div>`;
                        }

                        laneEl.appendChild(blockEl);
                    });

                    targetContainer.appendChild(laneEl);
                });
            }

            updateStacksAndQueue() {
                const stacksContainer = document.getElementById('stacksContainer');
                stacksContainer.innerHTML = '';
                this.stacks.forEach((stack, stackIndex) => {
                    const stackEl = document.createElement('div');
                    stackEl.className = 'stack';

                    stack.forEach((block, blockIndex) => {
                        const blockEl = document.createElement('div');
                        blockEl.className = `stack-block ${block.color}`;
                        blockEl.innerHTML = `<div class="block-number">${block.number}</div><div class="block-label">${blockIndex === stack.length - 1 ? 'TOP' : 'WAIT'}</div>`;

                        blockEl.onclick = null;
                        blockEl.removeEventListener('click', this.handleBlockClick);

                        // 수정된 부분: 블록을 클릭할 때마다 실시간으로 대기열 상태를 확인
                        if (blockIndex === stack.length - 1 && this.gameRunning) {
                            blockEl.classList.add('top-block');
                            blockEl.addEventListener('click', () => {
                                // 클릭 시점에 실시간으로 대기열 상태를 확인
                                const currentAvailableSlot = this.getAvailableQueueSlot();
                                if (currentAvailableSlot !== -1) {
                                    this.handleBlockClick(stackIndex);
                                } else {
                                    this.showMessage('대기열이 가득 찼습니다!', 'warning');
                                }
                            });
                        } else {
                            blockEl.style.cursor = 'not-allowed';
                        }

                        stackEl.appendChild(blockEl);
                    });

                    stacksContainer.appendChild(stackEl);
                });

                const queueArea = document.getElementById('queueArea');
                for (let i = 0; i < 4; i++) {
                    const slot = queueArea.children[i];
                    slot.innerHTML = '';
                    slot.className = 'queue-slot';

                    if (this.attackQueue[i]) {
                        const block = this.attackQueue[i];
                        slot.className = `queue-block ${block.color} ${!block.isFiring ? 'added' : ''}`;
                        slot.innerHTML = `<div class="block-number">${block.number}</div><div class="block-label">${block.isFiring ? 'FIRING' : 'QUEUE'}</div>`;
                    } else {
                        slot.innerHTML = 'Empty';
                    }
                }
            }

            updateTargetLanesAndQueue() {
                console.log('updateTargetLanesAndQueue: Updating partial UI', { startTime: performance.now() });
                this.updateTargetLanes();
                this.updateQueue();
                console.log('updateTargetLanesAndQueue: Partial UI updated', { endTime: performance.now() });
            }

            updateQueue() {
                const queueArea = document.getElementById('queueArea');
                for (let i = 0; i < 4; i++) {
                    const slot = queueArea.children[i];
                    slot.innerHTML = '';
                    slot.className = 'queue-slot';

                    if (this.attackQueue[i]) {
                        const block = this.attackQueue[i];
                        slot.className = `queue-block ${block.color} ${!block.isFiring ? 'added' : ''}`;
                        slot.innerHTML = `<div class="block-number">${block.number}</div><div class="block-label">${block.isFiring ? 'FIRING' : 'QUEUE'}</div>`;
                    } else {
                        slot.innerHTML = 'Empty';
                    }
                }
            }

            handleBlockClick(stackIndex) {
                console.log('handleBlockClick: Stack', stackIndex, 'clicked at', new Date().toISOString());
                this.selectBlock(stackIndex);
            }

            showMessage(text, type = '') {
                const messageEl = document.getElementById('message');
                messageEl.textContent = text;
                messageEl.className = `message ${type}`;

                setTimeout(() => {
                    if (messageEl) {
                        messageEl.textContent = '';
                        messageEl.className = 'message';
                    }
                }, 2200);
            }
        }

        let game;

        function startIntroGame() {
            console.log('startIntroGame: Starting game');
            document.getElementById('intro').style.display = 'none';
            document.getElementById('gameContainer').style.display = 'block';

            if (!game) {
                game = new ColorShooterGame();
                game.initGame();
            }
            game.startGame();
        }

        function resetGame() {
            console.log('resetGame: Triggered');
            if (game) game.resetGame();
        }

        window.onload = function() {
            console.log('window.onload: Page loaded');
        };
    </script>
</body>
</html>